/*
 * Copyright (C) 2016 Elias N Vasylenko <eliasvasylenko@gmail.com>
 *
 * This file is part of uk.co.strangeskies.text.
 *
 * uk.co.strangeskies.text is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * uk.co.strangeskies.text is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with uk.co.strangeskies.text.  If not, see <http://www.gnu.org/licenses/>.
 */
package uk.co.strangeskies.text.properties;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.Collections.unmodifiableSet;
import static uk.co.strangeskies.text.properties.PropertyConfiguration.UNSPECIFIED_KEY_SPLIT_STRING;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Proxy;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Objects;
import java.util.Optional;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import uk.co.strangeskies.text.CamelCaseFormatter;
import uk.co.strangeskies.text.CamelCaseFormatter.UnformattingCase;
import uk.co.strangeskies.text.parsing.Parser;
import uk.co.strangeskies.text.properties.PropertyConfiguration.Case;
import uk.co.strangeskies.text.properties.PropertyLoaderImpl.MethodSignature;
import uk.co.strangeskies.utilities.Log.Level;
import uk.co.strangeskies.utilities.ObservableImpl;
import uk.co.strangeskies.utilities.ObservablePropertyImpl;
import uk.co.strangeskies.utilities.ObservableValue;
import uk.co.strangeskies.utilities.classloading.DelegatingClassLoader;

/**
 * Delegate implementation object for proxy instances of LocalizationText
 * classes. This class deals with most method interception from the proxies
 * generated by {@link PropertyLoader}.
 * 
 * @author Elias N Vasylenko
 *
 * @param <A>
 *          the type of the delegating {@link Properties} proxy
 */
public class PropertiesDelegate<A extends Properties<A>> extends ObservableImpl<A> implements Properties<A> {
	/*
	 * Implementation of localised property
	 */
	class LocalizedPropertyImpl<T> extends ObservablePropertyImpl<T, T> implements Localized<T>, Consumer<A> {
		private final String key;
		private final ResourceBundle bundle;
		private final Class<T> propertyClass;
		private final MethodSignature signature;
		private final List<Object> arguments;

		public LocalizedPropertyImpl(String key, ResourceBundle bundle, Class<T> propertyClass, MethodSignature signature,
				List<?> arguments) {
			super((r, t) -> r, Objects::equals, null);

			this.key = key;
			this.bundle = bundle;
			this.propertyClass = propertyClass;
			this.signature = signature;
			this.arguments = new ArrayList<>(arguments);

			updateText();

			PropertiesDelegate.this.addWeakObserver(this);
		}

		private synchronized void updateText() {
			PropertyProvider<T> provider = getClassProvider(key, propertyClass);
			PropertyValue<T> propertyValue = loadValue(bundle, key, provider);
			Optional<T> instantiatedValue = propertyValue.instantiate(arguments);
			T value = instantiatedValue.orElse(null);

			set(value);
		}

		@Override
		public String toString() {
			return get().toString();
		}

		@Override
		public T get(Locale locale) {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public void accept(A t) {
			updateText();
		}

		@Override
		public ObservableValue<Locale> locale() {
			return loader.locale();
		}
	}

	private static final Set<MethodSignature> LOCALIZATION_HELPER_METHODS = getLocalizationHelperMethods();

	private static Set<MethodSignature> getLocalizationHelperMethods() {
		Set<MethodSignature> signatures = new HashSet<>();

		for (Method method : Properties.class.getMethods()) {
			signatures.add(new MethodSignature(method));
		}
		for (Method method : Object.class.getMethods()) {
			signatures.add(new MethodSignature(method));
		}

		return unmodifiableSet(signatures);
	}

	private static final Constructor<MethodHandles.Lookup> METHOD_HANDLE_CONSTRUCTOR = getMethodHandleConstructor();

	private static Constructor<Lookup> getMethodHandleConstructor() {
		try {
			Constructor<Lookup> constructor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);

			if (!constructor.isAccessible()) {
				constructor.setAccessible(true);
			}

			return constructor;
		} catch (NoSuchMethodException | SecurityException e) {
			throw new RuntimeException(e);
		}
	}

	private final PropertyLoaderImpl loader;
	private final PropertyResourceConfiguration<A> source;
	private final A proxy;

	private final Map<PropertyResourceConfiguration<?>, PropertyResourceBundle> bundleCache = new ConcurrentHashMap<>();
	private final Map<MethodSignature, PropertyValue<?>> valueCache = new ConcurrentHashMap<>();

	private final Consumer<Locale> observer;

	PropertiesDelegate(PropertyLoaderImpl loader, PropertyResourceConfiguration<A> source) {
		this.source = source;

		if (!source.getAccessor().isInterface()) {
			throw loader.log(Level.ERROR,
					new PropertyLoaderException(loader.getText().mustBeInterface(source.getAccessor())));
		}
		this.loader = loader;

		proxy = createProxy(source.getAccessor());

		initialize(source.getAccessor());

		observer = l -> {
			bundleCache.replaceAll((c, b) -> b.withLocale(l));
			fire(this.proxy);
		};
		loader.locale().addWeakObserver(observer);
	}

	private void initialize(Class<A> accessor) {
		for (Method method : accessor.getMethods()) {
			MethodSignature signature = new MethodSignature(method);

			if (!LOCALIZATION_HELPER_METHODS.contains(signature) && !method.isDefault()) {

			}
		}
	}

	private ResourceBundle getBundle(PropertyResourceConfiguration<?> configuration) {
		return bundleCache.computeIfAbsent(configuration, c -> {
			PropertyResourceStrategy strategy = loader.getResourceStrategyInstance(source.getConfiguration().strategy());
			return strategy.findLocalizedResourceBundle(getLocale(), source);
		});
	}

	private Object getValue(MethodSignature signature, Object... arguments) {
		List<?> argumentList;
		if (arguments == null) {
			argumentList = emptyList();
		} else {
			argumentList = asList(arguments);
		}

		PropertyValue<?> value = valueCache.computeIfAbsent(signature, k -> createValue(k));

		return value.instantiate(argumentList).orElse(null);
	}

	private PropertyValue<?> createValue(MethodSignature signature) {
		PropertyResourceConfiguration<A> source;
		PropertyConfiguration configuration = signature.method().getAnnotation(PropertyConfiguration.class);
		if (configuration != null) {
			source = this.source.derive(configuration);
		} else {
			source = this.source;
		}

		try {
			return arguments -> (Optional<Object>) createValue(source, signature, arguments);
		} catch (Exception e) {
			if (source.getAccessor().equals(PropertyLoaderProperties.class)) {
				return arguments -> {
					try {
						return Optional.of(signature.method().invoke(loader.getText(), arguments.toArray()));
					} catch (Exception e2) {
						/*
						 * TODO handle better
						 */
						throw new RuntimeException(e2);
					}
				};
			} else {
				throw e;
			}
		}
	}

	private String getKey(PropertyResourceConfiguration<A> source, MethodSignature signature, List<?> arguments) {
		String key = source.getConfiguration().key();
		if (key.equals(PropertyConfiguration.UNSPECIFIED_KEY)) {
			key = PropertyConfiguration.QUALIFIED_SCOPED;
		}

		Object[] substitution = new Object[arguments.size() + 3];
		substitution[0] = formatKeyComponent(source, signature.getClass().getPackage().getName());
		substitution[1] = formatKeyComponent(source, signature.getClass().getSimpleName());
		substitution[2] = formatKeyComponent(source, signature.method().getName());
		int i = 3;
		for (Object argument : arguments) {
			substitution[i++] = argument;
		}

		return String.format(key, substitution);
	}

	private Object formatKeyComponent(PropertyResourceConfiguration<A> source, String name) {
		String splitString = source.getConfiguration().keySplitString();
		if (!splitString.equals("") && !splitString.equals(UNSPECIFIED_KEY_SPLIT_STRING)) {
			new CamelCaseFormatter(splitString, false, UnformattingCase.PRESERVED);
		}

		Case keyCase = source.getConfiguration().keyCase();
		if (keyCase == Case.LOWER) {
			splitString = splitString.toLowerCase();
		} else if (keyCase == Case.UPPER) {
			splitString = splitString.toUpperCase();
		}

		return splitString;
	}

	private <T> PropertyValue<T> loadValue(ResourceBundle bundle, String key, PropertyProvider<T> provider) {
		try {
			return provider.getParser().parse(bundle.getString(key));
		} catch (MissingResourceException e) {
			loader.log(Level.WARN, new PropertyLoaderException(loader.getText().translationNotFoundMessage(key), e));
		}

		return provider.getDefault(key);
	}

	private Optional<?> createValue(PropertyResourceConfiguration<A> source, MethodSignature signature,
			List<?> arguments) {
		String key = getKey(source, signature, arguments);

		Type propertyType = signature.method().getGenericReturnType();
		Class<?> propertyClass = getPropertyClass(key, propertyType);

		ResourceBundle bundle = getBundle(source);

		if (Properties.class.isAssignableFrom(propertyClass)) {
			/*
			 * TODO return type annotation of @PropertyConfiguration isn't supported
			 * (yet?), but this is how it might look:
			 */
			PropertyConfiguration configuration = source
					.derive(signature.method().getAnnotatedReturnType().getAnnotation(PropertyConfiguration.class))
					.getConfiguration();

			return Optional.of(getPropertiesUnsafe(propertyClass, configuration));

		} else if (Localized.class.equals(propertyClass)) {
			return Optional
					.of(new LocalizedPropertyImpl<>(key, bundle, getElementClass(key, propertyType), signature, arguments));

		} else if (List.class.equals(propertyClass)) {
			try {
				return getListParser(key, getElementClass(key, propertyType)).parse(bundle.getString(key))
						.instantiate(arguments);
			} catch (MissingResourceException e) {
				loader.log(Level.WARN, new PropertyLoaderException(loader.getText().translationNotFoundMessage(key), e));

				return Optional.of(emptyList());
			}

		} else {
			PropertyProvider<?> provider = getClassProvider(key, propertyClass);

			return loadValue(bundle, key, provider).instantiate(arguments);
		}
	}

	private Parser<PropertyValue<List<?>>> getListParser(String key, Class<?> propertyClass) {
		return Parser.list(getClassProvider(key, propertyClass).getParser(), "\\s*,\\s*")
				.transform(list -> arguments -> Optional.of(list.stream().map(element -> element.instantiate(arguments))
						.filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList())));
	}

	private <T> PropertyProvider<T> getClassProvider(String key, Class<T> propertyClass) {
		/*
		 * get parser for class
		 */
		List<PropertyProvider<T>> providers = loader.getProviders(propertyClass);

		/*
		 * TODO aggregate defaults and parsers into one...
		 */

		return providers.get(0);
	}

	@SuppressWarnings("unchecked")
	private <U extends Properties<U>> U getPropertiesUnsafe(Class<?> returnType, PropertyConfiguration configuration) {
		return loader.getProperties((Class<U>) returnType, configuration);
	}

	private Class<?> getPropertyClass(String key, Type propertyType) {
		if (propertyType instanceof Class<?>) {
			return (Class<?>) propertyType;
		} else if (propertyType instanceof ParameterizedType) {
			return (Class<?>) ((ParameterizedType) propertyType).getRawType();
		} else {
			throw new PropertyLoaderException(loader.getText().illegalReturnType(propertyType, key));
		}
	}

	private Class<?> getElementClass(String key, Type propertyType) {
		Class<?> elementClass;

		if (propertyType instanceof ParameterizedType) {
			Type elementType = ((ParameterizedType) propertyType).getActualTypeArguments()[0];
			elementClass = getPropertyClass(key, elementType);
		} else {
			elementClass = Object.class;
		}

		return elementClass;
	}

	@Override
	public Locale getLocale() {
		return loader.getLocale();
	}

	@Override
	public A copy() {
		return proxy;
	}

	@SuppressWarnings("unchecked")
	A createProxy(Class<A> accessor) {
		ClassLoader classLoader = new DelegatingClassLoader(getClass().getClassLoader(), accessor.getClassLoader());

		return (A) Proxy.newProxyInstance(classLoader, new Class<?>[] { accessor },
				(Object p, Method method, Object[] args) -> {
					MethodSignature signature = new MethodSignature(method);

					if (LOCALIZATION_HELPER_METHODS.contains(signature)) {
						return method.invoke(PropertiesDelegate.this, args);
					}

					if (method.isDefault()) {
						return METHOD_HANDLE_CONSTRUCTOR.newInstance(method.getDeclaringClass(), MethodHandles.Lookup.PRIVATE)
								.unreflectSpecial(method, method.getDeclaringClass()).bindTo(p).invokeWithArguments(args);
					}

					return getValue(signature, args);
				});
	}
}
