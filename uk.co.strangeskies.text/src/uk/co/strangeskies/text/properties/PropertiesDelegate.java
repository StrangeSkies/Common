/*
 * Copyright (C) 2016 Elias N Vasylenko <eliasvasylenko@gmail.com>
 *
 * This file is part of uk.co.strangeskies.text.
 *
 * uk.co.strangeskies.text is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * uk.co.strangeskies.text is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with uk.co.strangeskies.text.  If not, see <http://www.gnu.org/licenses/>.
 */
package uk.co.strangeskies.text.properties;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.Collections.unmodifiableSet;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Proxy;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import uk.co.strangeskies.text.parsing.Parser;
import uk.co.strangeskies.text.properties.PropertyLoaderImpl.MethodSignature;
import uk.co.strangeskies.utilities.Log.Level;
import uk.co.strangeskies.utilities.ObservableImpl;
import uk.co.strangeskies.utilities.ObservablePropertyImpl;
import uk.co.strangeskies.utilities.ObservableValue;
import uk.co.strangeskies.utilities.classloading.DelegatingClassLoader;

/**
 * Delegate implementation object for proxy instances of LocalizationText
 * classes. This class deals with most method interception from the proxies
 * generated by {@link PropertyLoader}.
 * 
 * @author Elias N Vasylenko
 *
 * @param <A>
 *          the type of the delegating {@link Properties} proxy
 */
public class PropertiesDelegate<A extends Properties<A>> extends ObservableImpl<A> implements Properties<A> {
	/*
	 * Implementation of localised property
	 */
	class LocalizedPropertyImpl<T> extends ObservablePropertyImpl<T, T> implements Localized<T>, Consumer<A> {
		private final String key;
		private final Class<T> propertyClass;
		private final MethodSignature signature;
		private final List<Object> arguments;

		public LocalizedPropertyImpl(String key, Class<T> propertyClass, MethodSignature signature, List<?> arguments) {
			super((r, t) -> r, Objects::equals, null);

			this.key = "";
			this.propertyClass = propertyClass;
			this.signature = signature;
			this.arguments = new ArrayList<>(arguments);

			updateText();

			PropertiesDelegate.this.addWeakObserver(this);
		}

		@SuppressWarnings("unchecked")
		private synchronized void updateText() {
			String valueString = loadTranslation(key);

			T value = getClassParser(key, propertyClass).parse(valueString).instantiate(arguments).orElse(null);

			if (value == null) {
				if (source.getAccessor().equals(PropertyLoaderProperties.class)) {
					try {
						value = ((Localized<T>) signature.method().invoke(loader.getText(), arguments)).get();
					} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
						/*
						 * 
						 * 
						 * TODO proper error message.....
						 * 
						 * 
						 * 
						 * 
						 * 
						 * 
						 * 
						 */
						throw new RuntimeException(e);
					}
				}
			}

			set(value);
		}

		@Override
		public String toString() {
			return get().toString();
		}

		@Override
		public T get(Locale locale) {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public void accept(A t) {
			updateText();
		}

		@Override
		public ObservableValue<Locale> locale() {
			return loader.locale();
		}
	}

	private static final Set<MethodSignature> LOCALIZATION_HELPER_METHODS = getLocalizationHelperMethods();

	private static Set<MethodSignature> getLocalizationHelperMethods() {
		Set<MethodSignature> signatures = new HashSet<>();

		for (Method method : Properties.class.getMethods()) {
			signatures.add(new MethodSignature(method));
		}
		for (Method method : Object.class.getMethods()) {
			signatures.add(new MethodSignature(method));
		}

		return unmodifiableSet(signatures);
	}

	private static final Constructor<MethodHandles.Lookup> METHOD_HANDLE_CONSTRUCTOR = getMethodHandleConstructor();

	private static Constructor<Lookup> getMethodHandleConstructor() {
		try {
			Constructor<Lookup> constructor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);

			if (!constructor.isAccessible()) {
				constructor.setAccessible(true);
			}

			return constructor;
		} catch (NoSuchMethodException | SecurityException e) {
			throw new RuntimeException(e);
		}
	}

	private final PropertyLoaderImpl loader;
	private final PropertyAccessorConfiguration<A> source;
	private final A proxy;

	private PropertyResourceBundle bundle;

	private final Map<MethodSignature, PropertyValue<?>> cache = new ConcurrentHashMap<>();

	private final Consumer<Locale> observer;

	PropertiesDelegate(PropertyLoaderImpl localizer, PropertyAccessorConfiguration<A> source) {
		this.source = source;

		if (!source.getAccessor().isInterface()) {
			throw localizer.log(Level.ERROR,
					new PropertyLoaderException(localizer.getText().mustBeInterface(source.getAccessor())));
		}

		this.loader = localizer;
		PropertyResourceStrategy strategy = localizer.getResourceStrategyInstance(source.getConfiguration().strategy());
		this.bundle = strategy.findLocalizedResourceBundle(getLocale(), source);

		proxy = createProxy(source.getAccessor());

		initialize(source.getAccessor());

		observer = l -> {
			this.bundle = this.bundle.withLocale(l);
			fire(this.proxy);
		};
		localizer.locale().addWeakObserver(observer);
	}

	private void initialize(Class<A> accessor) {
		for (Method method : accessor.getMethods()) {
			MethodSignature signature = new MethodSignature(method);

			if (!LOCALIZATION_HELPER_METHODS.contains(signature) && !method.isDefault()) {

			}
		}
	}

	Object getValue(MethodSignature signature, Object... arguments) {
		List<?> argumentList;
		if (arguments == null) {
			argumentList = emptyList();
		} else {
			argumentList = asList(arguments);
		}

		PropertyValue<?> value = cache.computeIfAbsent(signature, k -> createValue(k));

		return value.instantiate(argumentList);
	}

	private PropertyValue<?> createValue(MethodSignature signature) {
		PropertyAccessorConfiguration<A> source = this.source;
		PropertyConfiguration configuration = signature.method().getAnnotation(PropertyConfiguration.class);
		if (configuration != null) {
			source = source.derive(configuration);
		}

		String key = createKey(source, signature);

		return createValue(source, signature, key);
	}

	private String createKey(PropertyAccessorConfiguration<A> source, MethodSignature signature) {
		return null;
	}

	private PropertyValue<?> createValue(PropertyAccessorConfiguration<A> source, MethodSignature signature, String key) {
		Type propertyType = signature.method().getGenericReturnType();

		Class<?> propertyClass = getPropertyClass(key, propertyType);

		if (Properties.class.isAssignableFrom(propertyClass)) {
			/*
			 * TODO return type annotation of @PropertyConfiguration isn't supported
			 * (yet?), but this is how it might look:
			 */
			PropertyConfiguration configuration = source
					.derive(signature.method().getAnnotatedReturnType().getAnnotation(PropertyConfiguration.class))
					.getConfiguration();

			return getPropertiesUnsafe(propertyClass, configuration);

		} else if (List.class.equals(propertyClass)) {
			return getListParser(key, getElementClass(key, propertyType)).parse(loadTranslation(key));

		} else if (Localized.class.equals(propertyClass)) {
			return a -> Optional.of(new LocalizedPropertyImpl<>(key, getElementClass(key, propertyType), signature, a));

		} else {
			return getClassParser(key, propertyClass).parse(loadTranslation(key));
		}
	}

	private Parser<PropertyValue<List<?>>> getListParser(String key, Class<?> propertyClass) {
		return Parser.list(getClassParser(key, propertyClass), "\\s*,\\s*")
				.transform(list -> arguments -> Optional.of(list.stream().map(element -> element.instantiate(arguments))
						.filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList())));
	}

	private <T> Parser<PropertyValue<T>> getClassParser(String key, Class<T> propertyClass) {
		/*
		 * get parser for class
		 */
		List<PropertyProvider<T>> providers = loader.getProviders(propertyClass);

		return providers.get(0).getParser();
	}

	@SuppressWarnings("unchecked")
	private <U extends Properties<U>> U getPropertiesUnsafe(Class<?> returnType, PropertyConfiguration configuration) {
		return loader.getProperties((Class<U>) returnType, configuration);
	}

	private Class<?> getPropertyClass(String key, Type propertyType) {
		if (propertyType instanceof Class<?>) {
			return (Class<?>) propertyType;
		} else if (propertyType instanceof ParameterizedType) {
			return (Class<?>) ((ParameterizedType) propertyType).getRawType();
		} else {
			throw new PropertyLoaderException(loader.getText().illegalReturnType(propertyType, key));
		}
	}

	private Class<?> getElementClass(String key, Type propertyType) {
		Class<?> elementClass;

		if (propertyType instanceof ParameterizedType) {
			Type elementType = ((ParameterizedType) propertyType).getActualTypeArguments()[0];
			elementClass = getPropertyClass(key, elementType);
		} else {
			elementClass = Object.class;
		}

		return elementClass;
	}

	private String loadTranslation(String key) {
		try {
			return bundle.getString(key);
		} catch (MissingResourceException e) {
			loader.log(Level.WARN, new PropertyLoaderException(loader.getText().translationNotFoundMessage(key), e));
		}

		return null;
	}

	@Override
	public Locale getLocale() {
		return loader.getLocale();
	}

	@Override
	public A copy() {
		return proxy;
	}

	@SuppressWarnings("unchecked")
	A createProxy(Class<A> accessor) {
		ClassLoader classLoader = new DelegatingClassLoader(getClass().getClassLoader(), accessor.getClassLoader());

		return (A) Proxy.newProxyInstance(classLoader, new Class<?>[] { accessor },
				(Object p, Method method, Object[] args) -> {
					MethodSignature signature = new MethodSignature(method);

					if (LOCALIZATION_HELPER_METHODS.contains(signature)) {
						return method.invoke(PropertiesDelegate.this, args);
					}

					if (method.isDefault()) {
						return METHOD_HANDLE_CONSTRUCTOR.newInstance(method.getDeclaringClass(), MethodHandles.Lookup.PRIVATE)
								.unreflectSpecial(method, method.getDeclaringClass()).bindTo(p).invokeWithArguments(args);
					}

					return getValue(signature, args);
				});
	}
}
